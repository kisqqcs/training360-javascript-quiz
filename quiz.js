export const questions = [
    // 1. JS - Változók
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Változók 1 / 3',
        question:   'Melyik kulcsszóval létrehozott változók esetében van hoisting?<br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['var',
                    'let',
                    'const',
                    'Egyiknél sincs'],
        results:    'A, B, C',
        result:     123,
        boolres:    [true, true, true, false],
        answer:     'Mind a háromnál van hoisting, a különbség annyi,<br>hogy var esetében a változó inicializálódik is undefined kezdőértékkel.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Változók 2 / 3',
        question:   'Melyik kulcsszóval létrehozott változó esetében nem megengedett a reassignement (újra értékadás)?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['var',
                    'let',
                    'const',
                    'Mindegyiknél megengedett'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A const immutable bindingot hoz létre, nem lehet újra értéket adni a változónak.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Változók 3 / 3',
        question:   'Melyik állítások igazak a let, és const kulcsszóval deklarált változókra?<br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['nem lehet őket újradeklarálni',
                    'blokk hatókörűek',
                    'inicializálás előtt nem elérhetőek',
                    'nem lehet új értéket adni nekik'],
        results:    'A, B, C',
        result:     123,
        boolres:    [true, true, true, false],
        answer:     'Egyedül a const kulcsszóval létrehozott változóknál nem engedélyezett a reassignment (új értéket adni a "= " operátorral).'
    },
    // 1. JS - Függvények
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Függvények 1 / 3',
        question:   'Hogy hívják azt a függvényt, amit más függvénynek adunk át paraméterként?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['callback function',
                    'arrow function',
                    'higher order function',
                    'IIFE'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Azt a függvényt, amelyet másik függvénynek adunk át paraméterként egyezményesen callback functionnek hívjuk.<br>Azt pedig, amelyik ezzel dolgozik, higher order functionnek.<br>Az arrow function  egy újabb szintaxis function expression létrehozására, illetve rendelkezik néhány speciális tulajdonsággal.<br>Az IIFE (Immediately Invoked Function Expression - Azonnal Meghívott Függvény Kifejezés) segítségével oylan függvényeket tudunk írni, ami a definiálásakor rögtön le is fut.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Függvények 2 / 3',
        question:   'Melyik állítások helyesek a JavaScript memóriakezelésével kapcsolatban?<br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['A Heap rendezetlen memóriaterület',
                    'A Stackben tárolódnak az objektumok',
                    'A Heapben tárolódnak a primitívek',
                    'A JavaScriptben automatikus a szemétgyűjtés'],
        results:    'A, D',
        result:     14,
        boolres:    [true, false, false, true],
        answer:     'A Heap egy rendezetlen nagyméretű memóriaterület, ahol az objektumok tárolódnak.<br>A Stack mérete sokkal korlátozottabb, a primitívek itt tárolódnak.<br>A JavaScriptben a szemétgyűjtés automatikus. A Garbage Collector munkájába nem tudunk közvetlenül beleavatkozni.'
    },

    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Függvények 3 / 3',
        question:   'Melyik állítás igaz az arrow functionre?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['nem bindolja a this-t',
                    'a paramétert/paramétereket  kötelező zárójelbe tenni',
                    'objektum nem szerepelhet visszatérési értékként',
                    'mindig használnunk kel la return utasítást a függvényen belül'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Az arrow function nem köti a saját thist ezért ne használjuk objektum metódusaként.<br>Amennyiben csak egy darab paraméter van, azt nem kötelező zárójelbe tenni.<br>Arrow function esetében, akárcsak hagyományos függvényeknél, bármilyen típusú adat lehet visszatérési érték.<br>Return utasítást nem kötelező használni, lehet implicit visszatérési értékünk.'
    },
    // 1. JS - Tömbök
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Tömbök 1 / 3',
        question:   'Melyik metódus módosítja az eredeti tömböt?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['forEach()',
                    'map()',
                    'reduce()',
                    'egyik sem'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A fenti metódusok az eredeti tömböt nem módosítják, azaz nem mutálják ellenben a push(), pop(), shift(), unshift() metódusok például igen.<br>Érdemes mindig olyan megoldásokra törekednünk, amelyek az eredeti tömböt nem módosítják.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Tömbök 2 / 3',
        question:   'Az alábbi metódushívásnak mi lesz a visszatérési értéke?<br>[0, null ,undefined, \'\'].filter(item => item)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['[ ]',
                    '[0]',
                    '[0, null ,undefined, \'\']',
                    '[null, \'\']'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Üres tömböt fogok visszakapni, mert feltételvizsgálatnál mind a 0, a null, az undefined, és az üres string is false-t ad vissza.'
    },
    {
        header1:    '1. JavaScript haladó - Változók, függvények és tömbök',
        header2:    'Tömbök 3 / 3',
        question:   'Mi lesz a value értéke? A 0 paraméter csak a kezdőértéket állítja be?<br>&emsp; const value = [{v: 1}, {v: 2}, {v: 3}].reduce(<br>(accumulator, currentValue) => accumulator + currentValue.v, 0)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    '3',
                    '6'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A reduce jelen esetben nem csinál mást, mint hogy összeadja a tömbben lévő objektumok v tulajdonságainak az értékét.<br>A kezdőértéket 0-ra állítjuk, és az accumulator-ban ehhez folyamatosan hozzáadjuk a soron lévő objektum v tulajdonságának értékét.'
    },
    // 2. JS - Szövegek
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Szövegek 1 / 3',
        question:   'Mi lesz a b értéke a függvényen belül?<br>function restParameter(a, ...b) {<br>&emsp; //...<br>}<br>restParameter(1, 2, 3, 4, 5);<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['2',
                    '[1]',
                    '[2, 3, 4, 5]',
                    '[1, 2, 3, 4, 5]'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Jelen esetben rest paramétert használtunk.<br>Az a értéke 1 lesz, míg a b értéke az összes többi paraméter tömbösítve, tehát: [2, 3, 4, 5].'
    },

    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Szövegek 2 / 3',
        question:   'Az alábbi kód lefutása után mi lesz a konzolon?<br>const age = { age: 33 }<br>const name = { firstname: \'John\', lastname: \'Doe\'}<br>console.log({...name, ...age })<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['{ firstname: \'John\', lastname: \'Doe\', age: 33 }',
                    '[ firstname: \'John\', lastname: \'Doe\', { age: 33 } ]',
                    '[ { firstname: \'John\', lastname: \'Doe\'}, { age: 33 } ]',
                    '[ \'John\', \'Doe\', 33 ]'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'Két objektumot fűztünk össze.<br>A kimeneten egy olyan új objektum lesz, amely mind a kettő tulajdonságait tartalmazza.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Szövegek 3 / 3',
        question:   'Melyik kifejezés nem lenne helyes egy konzolra való kiíráskor, amennyiben a kiinduló kód a következő:<br>const a = 10<br>const b = 20<br>const sum = (firstNumber, secondNumber) => firstNumber + secondNumber <br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['érték: ${a + b}',
                    'érték: ${sum(a, b)}',
                    'érték: ${sum(firstNumber, secondNumber)}',
                    'érték: ${sum(10, 20)}'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A firstNumber és a secondNumber a paraméterek nevei, csak függvényen belül használhatom őket.<br>A függvényen kívül nem léteznek, tehát itt ReferenceError-t kapunk.'
    },
    // 2. JS - Számok, és a Math objektum
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Számok, és a Math objektum 1 / 3',
        question:   'Mi lesz a két visszatérési érték az alábbi esetekben?<br>isNaN(\'value\')<br>Number.isNaN(\'value\')<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['true, true',
                    'true, false',
                    'false, true',
                    'false, false'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A globális isNaN() loose equality-t használ, addig a Number.isNaN() strict equality-t, tehát a típust is vizsgálja nem csak az értéket.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Számok, és a Math objektum 2 / 3',
        question:   'Az alábbiak közül milyen számrendszerbeli számokkal tudunk dolgozni JavaScriptben?<br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['bináris (2)',
                    'oktális (8)',
                    'decimális (10)',
                    'hexadecimális (16)'],
        results:    'A, B, C, D',
        result:     1234,
        boolres:    [true, true, true, true],
        answer:     'Mindegyik helyes megoldás volt.<br>Alaphelyzetben 10-es számrendszerbeli számokkal dolgozunk, azonban 0b, 0o, 0x előtagokkal megadott számok automatikusan a bináris, oktális, és hexadecimális számrendszerbe fognak tartozni.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Számok, és a Math objektum 3 / 3',
        question:   'Maximum mekkora értéket vehetnek fel a BigInt típusú számok?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A Number.MAX_SAFE_INTEGER segítségével lekérdezhető',
                    'A Number.MAX_VALUE segítségével lekérdezhető',
                    'Nincs elvi korlátja, maximum a memória mennyisége szab neki határt',
                    'Pontosan 10 a századikon a legnagyobb ábrázolható érték'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A BigInt típusnak nincs a mérete lekorlátozva. Amíg van elég memória bármekkora értéket felvehet.'
    },
    // 2. JS - Adatok átstrukturálása
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Adatok átstrukturálása 1 / 3',
        question:   'Mi lesz az n és az s és k változók értéke?<br>&emsp; const pet = {<br>&emsp; &emsp; name: \'Szetti\',<br>&emsp; &emsp; species: \'dog\',<br>&emsp; &emsp; age: 3<br>&emsp; }<br><br>&emsp; const { name: n, species: s, kor: k = 10 } = pet;<br>Válaszd ki az EGYETLEN megfelelő választ!<br>',
        options:    ['Szetti\', \'dog\', 3',
                    'Szetti\', \'dog\', 10',
                    '\'Szetti\', \'dog\', undefined',
                    'Hibás a kód'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A pet objektum nem rendelkezik kor tulajdonsággal, így a megadott default value, azaz 10 lesz az értéke.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Adatok átstrukturálása 2 / 3',
        question:   'Mi lesz az a és a d változók értéke?<br>&emsp; const arr = [\'one\', \'two\', \'three\', \'four\'];<br>&emsp; const [a, , , d] = arr;<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'one\', \'two\'',
                    '\'one\', \'three\'',
                    '\'one\', \'four\'',
                    'Hibás a kód'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Az a értéke a tömb első elemének az értékét veszi fel, majd két elemet kihagyunk, a d a negyedik elem, azaz a 3. indexű elem értékét kapja meg ami \'four\''
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Adatok átstrukturálása 3 / 3',
        question:   'Mi lesz a pet objektum name tulajdonságának az értéke a kód lefutása után?<br>&emsp; const pet = {<br>&emsp; &emsp; name: \'Szetti\',<br>&emsp; &emsp; species: \'dog\',<br>&emsp; &emsp; age: 3<br>&emsp; }<br><br>&emsp; let { name } = pet<br>&emsp; name = \'Bogyó\'<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Szetti',
                    'Bogyó',
                    'undefined',
                    'Hibás a kód'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A destructuring után a referencia elveszik. A name egy egyszerű primitív lesz. Ha azt módosítjuk az objektum tulajdonsága nem fog módosulni.'
    },
    // 2. JS - Dátumok
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Dátumok 1 / 3',
        question:   'Az alábbi kód esetében a date változónál a 2020-as év melyik hónapja és napja van beállítva?<br>&emsp; const date = new Date(2020, 1, 1)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['január 1.',
                    'február 1.',
                    'január 2.',
                    'február 2.'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Mivel a hónapok 0-tól kezdődően számozódnak (mint a tömbindexek), ezért az 1 a február hónapot jelöli.<br>A második egyes a nap száma, az 1-től számozódik.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Dátumok 2 / 3',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br>&emsp; const date = new Date(2020, 0, 1)<br>&emsp; date.setDate(32)<br>&emsp; console.log(date)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Jan 01 2020',
                    'Jan 32 2020',
                    'Feb 01 2020',
                    'RangeError: Invalid argument.'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Trükkös volt. A január 1-et módosítjuk. A napszámot 32-re átállítottam.<br>Ugyan januárban nincs 32. nap, azonban ez nem probléma, mert ilyen esetben automatikusan ugrik a következő dátumra.<br>Tehát januárban 31 nap van, plusz egy az február 1.'
    },
    {
        header1:    '2. JavaScript haladó - Szövegek, számok és a Math objektum, dátumok, adatok átstrukturálása',
        header2:    'Dátumok 3 / 3',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br>&emsp; const date = Date.UTC(2020, 0, 1)<br>&emsp; console.log(date)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Egy date object UTC alapú értékkel',
                    'Egy date object lokális idő alapú értékkel',
                    '1970 január 1 óta eltelt idő ezredmásodpercben',
                    'Error'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Az UTC() metódus az 1970 január 1 óta eltelt időt adja vissza ezredmásodpercben.'
    },
    // 3. JS - Modulok és kivételek
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Egyéb újdonságok 1 / 3',
        question:   'Melyik adatszerkezetben nem lehetséges duplikált elemek elhelyezése?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Array',
                    'Map',
                    'Set',
                    'WeakMap'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     '<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank">Dokumentáció</a>'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Egyéb újdonságok 2 / 3',
        question:   'Melyik metódus nem érhető el WeakMap esetben?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['get',
                    'set',
                    'delete',
                    'clear'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     '<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">Dokumentáció</a><br>A WeakMap csak get(), set(), has(), delete() metódusokkal rendelkezik.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Egyéb újdonságok 3 / 3',
        question:   'Mi lesz a konzolon?<br>&emsp; const id = Symbol(\'id\');<br>&emsp; const person = {<br>&emsp; &emsp; [id]: 1,<br>&emsp; &emsp; firstName: \'John\',<br>&emsp; &emsp; lastName: \'Doe\'<br>&emsp; }<br>&emsp; console.log(person.id)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    'undefined',
                    'Symbol(id): 1',
                    'Error'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A person id tulajdonságát a pont operátorral nem érjük el.<br>Használjuk a getOwnPropertySymbols() metódust a Symbol property-k elérésére, vagy itt akár a person[id]-t.'
    },
    // 3. JS - Web storage-ok
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Web storage-ok 1 / 3',
        question:   'Melyik storage típus tartalma törlődik a böngésző bezárásakor?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['cookie',
                    'sessionStorage',
                    'localStorage',
                    'egyiké sem'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A cookie és a localStorage megőrzi a benne tárolt adatokat, amíg mi vagy a user ki nem törli őket.<br>Ezzel szemben a sessionStorage, ahogy a neve is mondja csak az adott sessionre, azaz munkamenetre őrzi meg a tartalmat.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Web storage-ok 2 / 3',
        question:   'Mekkora lehet egy süti maximális mérete (általában)?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['4KB',
                    '5MB',
                    '25MB',
                    'Nincs korlátozva'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     '<a href="https://tools.ietf.org/html/rfc6265#section-4.1.1" target="_blank">Dokumentáció</a><br>RFC szabvány által van meghatározva.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Web storage-ok 3 / 3',
        question:   'Hol tároljuk a titkosítatlan jelszavakat?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['cookie-ban',
                    'localStorage-ben',
                    'sessionStorage-ben',
                    'Sehol'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A jelszavakat mindig sózzuk, titkosítjuk!'
    },
    // 3. JS - A JavaScript modul rendszere
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A JavaScript modul rendszere 1 / 3',
        question:   'Maximum hány darab export utasítás lehet egy file-ban?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    'Csak export default lehet, sima export nem',
                    'Akármennyi'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Az exportok száma nincs bekorlátozva a szabvány alapján.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A JavaScript modul rendszere 2 / 3',
        question:   'Maximum hány darab export default utasítás lehet egy file-ban?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    '32',
                    'Akármennyi'],
        results:    'A',
        result:     1,
        boolres:    [true, true, true, false],
        answer:     'Míg named export-ból akármennyi lehet, defaultból csak egy darab.<br>Akkor használjuk ha az adott file csak egy class-t, object-et stb. tartalmaz.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A JavaScript modul rendszere 3 / 3',
        question:   'Lehetséges az import utasítást feltételhez kötni? Pl.:<br>&emsp; if (condition) {<br>&emsp; &emsp; import { myModule } from \'./my.js\';<br>&emsp; }<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Igen, bármikor lehet',
                    'Nem lehet',
                    'Csak import as utasítás lehet feltételnél',
                    'Csak default export esetében lehet feltételhez kötött import'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Minden importnak a file elején kell szerepelnie. Tehát nem lehet ilyen módon feltételhez kötni.'
    },
    // 3. JS - A Regexp objektum
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A Regexp objektum 1 / 3',
        question:   'Melyik Regexp flag segítségével tudom case insensitive-en vizsgálni az illeszkedést?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['g',
                    'm',
                    'i',
                    'Nincs rá lehetőség'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Az i az ignorecase kapcsoló. Nem fog különbséget tenni a kis-, és nagybetűk között.<br>A g flaggel globális keresést, az m-el a többsoros keresést tudjuk bekapcsolni.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A Regexp objektum 2 / 3',
        question:   'Adott az alábbi reguláris kifejezés: ([A-Z])\w+/g<br>Hány találatunk lenne illeszkedés vizsgálatakor az alábbi mondat esetében?:<br>“RegExr was created By trining360.com.”<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['1',
                    '2',
                    '3',
                    '4'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Kettő darab nagybetűvel kezdődő szó van a mondatban, ezekre fog illeszkedni a kifejezés.<br>[A-Z]: legyen egy angol nagybetű <br>\w: utána az alábbiak közül: a-z, A-Z, 0-9, _<br>+: egy vagy több az előző karakterből<br>/g: globálisan keresünk'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'A Regexp objektum 3 / 3',
        question:   'Melyik stringre fog illeszkedni az alábbi minta?<br>&emsp; /^(\d{3} ){2}\d{3}$/<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['\'123456789\'',
                    '\'123 456 789\'',
                    '123',
                    '456 789'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'A leckék során már egyszer előkerült ez a példa. A TAJ számot validáltuk.<br>^(\d{3} ){2}: kezdődjön a string három darab számmal, ami után egy szóköz<br>{2}: az előbbiből legyen 2<br>\d{3}$: majd a végén legyen még 3 darab számjegy egymás után'
    },
    // 3. JS - Kivételkezelés
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Kivételkezelés 1 / 3',
        question:   'Egy try blokk után mennyi catch blokk lehet?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['csak egy',
                    'maximum 12 darab',
                    'akármennyi',
                    'ha van utána finally akkor akármennyi'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'JavaScriptben nem támogatott a multiple catch ág.<br>Ha több kivételt szeretnénk lekezelni, azt egy catch blokkon belül kell megtennünk.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Kivételkezelés 2 / 3',
        question:   'Milyen estben fut le finally ágban lévő kód?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['csak akkor, ha a try blokkban nem volt hiba',
                    'csak akkor, ha a try blokkban hiba volt, ilyenkor a catch blokk kódja után',
                    'csak akkor, ha a try blokkban hiba volt, ilyenkor a catch blokk kódja előtt',
                    'mindig'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Mindig. A finally mindig lefut akár volt hiba akár nem.'
    },
    {
        header1:    '3. JavaScript haladó - Modulok és kivételek',
        header2:    'Kivételkezelés 3 / 3',
        question:   'Milyen típusú hibát fogok kapni az alábbi kód esetében? (Csak ennyi a file tartalma!)<br>&emsp; try {<br>&emsp; &emsp; powFunction();<br>&emsp; } catch(error){<br>&emsp; &emsp; console.log(error.name);<br>&emsp; }<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['ReferenceError',
                    'SyntaxError',
                    'TypeError',
                    'RangeError'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'ReferenceError, mert nem létezik a powFunction nevű függvény.'
    },
    // 4. JS - Promise
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Promise 1 / 3',
        question:   'Az alábbiak közül melyik nem lehet egy Promise állapota?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['rejected',
                    'resolved',
                    'pending',
                    'canceled'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'A promise az alábbi állapotokkal rendelkezhet: pending, fulfilled, rejected, illetve settled ha fulfilled vagy rejected, de nem pending.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Promise 2 / 3',
        question:   'Mi lesz az alábbi kód lefutása után a konzolon?<br>&emsp; Promise.resolve(\'ok\')<br>&emsp; .then(data => {<br>&emsp; &emsp; return data.toUpperCase()<br>&emsp; })<br>&emsp; .then(data => {<br>&emsp; &emsp; console.log(data)<br>&emsp; &emsp; return data<br>&emsp; })<br>&emsp; .then(console.log)<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['ok',
                    'OK',
                    'ok, OK',
                    'OK, OK'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Az első then-ben nagybetűssé alakítjuk az ok stringet.<br>A második then-ben ezt kiírjuk a konzolra, és továbbadjuk.<br>A harmadik then ezt callback function-je a console.log, ami automatikusan megkapja a stringet, tehát felesleges ezt írnunk: data => console.log(data)'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Promise 3 / 3',
        question:   'Mit vált ki a fetch API?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['a setTimeout()-ot',
                    'az XMLHttpRequestet',
                    'a callback-eket',
                    'a Promise-okat'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     '<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">Dokumentáció</a>'
    },
    // 4. JS - Aszinkron programozás
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron programozás 1 / 3',
        question:   'Mire tipikus példa az alábbi kód?<br>&emsp; one(1, function () {<br>&emsp; &emsp; two(2, function () {<br>&emsp; &emsp; &emsp; three(3, function () {<br>&emsp; &emsp; &emsp; &emsp; four(4, function () {<br>&emsp; &emsp; &emsp; &emsp; &emsp; five(5)<br>&emsp; &emsp; &emsp; &emsp; })<br>&emsp; &emsp; &emsp; })<br>&emsp; &emsp; })<br>&emsp; })<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['async programming',
                    'callback hell',
                    'timer',
                    'loopback'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Függvény, ami paraméterként kap egy függvényt ami paraméterként kap egy függvényt, ami...<br>Callback hell. Callbacknek hívjuk a függvényt amit paraméterként adunk át másik függvénynek.<br>Ebből van sok egymásba ágyazva. Pokoli nehéz átlátni egy idő után.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron programozás 2 / 3',
        question:   'Mi lesz a konzolon az alábbi kód esetén, ha rákattintok a DOM-ba lévő click-me class-ű gombra?<br>&emsp; const btn = document.querySelector(\'.click-me\');<br><br>&emsp; btn.addEventListener(\'click\', () => {<br>&emsp; &emsp; console.log(\'Listener\');<br><br>&emsp; &emsp; setTimeout(console.log, 0, \'Timer\')<br><br>&emsp; &emsp; Promise<br>&emsp; &emsp; &emsp; .resolve(\'Promise1\')<br>&emsp; &emsp; &emsp; .then(console.log)<br><br>&emsp; &emsp; Promise<br>&emsp; &emsp; &emsp; .resolve(\'Promise2\')<br>&emsp; &emsp; &emsp; .then(console.log)<br>&emsp; })<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Promise1, Promise2, Listener, Timer',
                    'Listener, Timer, Promise1, Promise2',
                    'Listener, Promise1, Promise2, Timer',
                    'Timer, Promise1, Promise2, Listener'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Először lefut a szinkron kód, utána a Microtask queue-ben lévő 2 Promise, tehát Promise1, Promise2, és a végén a Task Queue-ben lévő timeout callbackje.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron programozás 3 / 3',
        question:   'Mi lesz a kimeneten?<br>&emsp; console.log(\'start\');<br>&emsp; setTimeout(console.log, 1000, \'1000\');<br>&emsp; console.log(\'end\');<br>&emsp; setTimeout(console.log, 0, \'0\');<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['start, 1000, end, 0',
                    'start, end, 1000, 0',
                    'start, end, 0, 1000',
                    '0, 1000, start, end'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'Először sorrendben a 2 szinkron utasítás: start, end<br>Utána a két callback, jelen esetben elsőnek a 0, mert itt sokkal kisebb volt a delay, (hacsak az előtte lévő console.log(‘end’) művelet lefuttatása nem tart egy másodpercig, és nem fog) mint az 1000-es párjánál, ami a legvégén fog csak lefutni.'
    },
    // 4. JS - Generátorok
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Generátorok 1 / 2',
        question:   'Mi a next() metódus visszatérési értéke?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['egy value, azaz valamilyen érték',
                    'egy boolean, amit true, ha a függvény befejezett egyéként false',
                    'egy object, amit done, és value tulajdonságokat tartalmaz',
                    'egy Promise'],
        results:    'C',
        result:     3,
        boolres:    [false, false, true, false],
        answer:     'A visszatérési érték egy olyan object, ahol a done property értéke true, ha a függvény befejezett egyéként false, a value property értéke pedig a yield utáni érték.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Generátorok 2 / 2',
        question:   'Válaszd ki az igaz állításokat!<br>Válaszd ki az ÖSSZES megfelelő választ!',
        options:    ['Meg lehet adni generátor függvényen belül a yield után értéknek egy másik generátor függvény hívás értékét',
                    'A hibakezelést mindig a generátor függvényen kívül kell megvalósítanunk, az nem tartalmazhat try catch blokkot',
                    'Generátor függvényen belül a return használata esetén mindig hibát kapunk',
                    'Generátor függvényeket kombinálhatunk Promise-okkal'],
        results:    'A, D',
        result:     14,
        boolres:    [true, false, false, true],
        answer:     'Meg lehet adni generátor függvényen belül a yield után értéknek egy másik generátor függvény hívás értékét: igaz, hiszen a yield* pont erre szolgál<br>A hibakezelést mindig a generátor függvényen kívül kell megvalósítanunk, az nem tartalmazhat try catch blokkot: hamis, példát is láthattunk a használatára<br>Generátor függvényen belül a return használata esetén mindig hibát kapunk: nem kapunk hibát egyszerűen next() metódushívásnál nem lesz ott return utáni érték<br>Generátor függvényeket kombinálhatunk Promise-okkal: természetesen, erre is láthattunk példát. Több fetch kérést küldtünk el a kettő kombinálásával.'
    },
    // 4. JS - Aszinkron függvények
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron függvények 1 / 2',
        question:   'Mi lesz az async function visszatérési értéke?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['amit megadunk return után',
                    'mindig egy Promise',
                    'egy Iterable',
                    'egy Iterator'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Az aszinkron függvények visszatérési értéke indig egy Promise.<br>A async await valójába csak egy egyszerűsített szintaxis a new Promise, then... részekre.'
    },
    {
        header1:    '4. JavaScript haladó - Aszinkron programozás',
        header2:    'Aszinkron függvények 2 / 2',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után, ha minden async hívás is véget ért?<br>&emsp; const thenable = {<br>&emsp; &emsp; age: 30,<br>&emsp; &emsp; then(resolve, reject) {<br>&emsp; &emsp; &emsp; setTimeout(() => resolve(this.age * 2), 1000)<br>&emsp; &emsp; }<br>&emsp; };<br><br>&emsp; async function f() {<br>&emsp; &emsp; const result = await thenable;<br>&emsp; &emsp; console.log(result)<br>&emsp; }<br><br>&emsp; f();<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Error',
                    '60',
                    'Promise',
                    'ƒ Function() { [native code] }'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Az await után megadtunk egy thenable objectet, tehát egy olyan objektumot aminek van then metódusa.<br>Tehát az await után a thenable object then metódusa hívódik meg. Ott egy setTimeout van, ami egy másodperc múlva meghívja resolve-ot, paraméterként átadva neki az age property értékének a dupláját a 2 * 30-at. Az f függvényen belül ezt az értéket fogjuk kiírni.'
    },
    // 5. JS - This
    {
        header1:    '# 5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 1 / 4',
        question:   'Mi lesz a this értéke a függvényen belül, amikor meghívjuk? (A globális környezetben vagyunk)<br>&emsp; \'use strict\';<br><br>&emsp; function myFunction() {<br>&emsp; &emsp; return this;<br>&emsp; }<br><br>&emsp; myFunction();<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A function',
                    'A Window object',
                    'null',
                    'undefined'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'Strict módban globális kódban elhelyezett függvény esetében mindig undefined.'
    },
    {
        header1:    '# 5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 2 / 4',
        question:   'Mi lesz a this értéke a függvényen belül, amikor meghívjuk? (A globális környezetben vagyunk)<br>&emsp; function myFunction() {<br>&emsp; &emsp; return this;<br>&emsp; }<br><br>&emsp; myFunction();<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A function',
                    'A Window object',
                    'null',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Strict mód nélkül globális kódban elhelyezett függvény esetében mindig a globális Window object.'
    },
    {
        header1:    '# 5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 3 / 4',
        question:   'Mi lesz a konzolon az alábbi kód lefutása után?<br>&emsp; \'use strict\';<br><br>&emsp; const user = {<br>&emsp; &emsp; name: \'John\',<br>&emsp; &emsp; myNameIs() {<br>&emsp; &emsp; &emsp; console.log(this.name);<br>&emsp; &emsp; }<br>&emsp; };<br><br>&emsp; const data = {<br>&emsp; &emsp; name: \'Jane\',<br>&emsp; }<br><br>&emsp; const person = user.myNameIs;<br>&emsp; person.call(data);<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['Jane',
                    'John',
                    'Window object',
                    'undefined'],
        results:    'A',
        result:     1,
        boolres:    [true, false, false, false],
        answer:     'A person-nak átadom a myNameIs metódus referenciáját.<br>Meghívom ezt a call-al a this értéknek a data-t adom meg, tehát a name értéke Jane lesz. Ez lesz a logon.'
    },
    {
        header1:    '# 5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'This 4 / 4',
        question:   'Mi lesz a konzolon, miután rákattintok a gombra? (A gomb a DOM része)<br>&emsp; document.body.insertAdjacentHTML(<br>&emsp; &emsp; \'afterend\', <br>&emsp; &emsp; \'<<span style="font-size: 0rem;"> </span>button onclick="console.log(this)">Click me<<span style="font-size: 0rem;"> </span>/button>\'<br>&emsp; );<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['A Window object',
                    'A Button element',
                    'Az Element',
                    'undefined'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Az onclick attributumnál hívjuk meg a console.log() metódust.<br>A Event a gombon következett be, a this maga a button lesz.'
    },
    // 5. JS - Objektumok – haladó
    {
        header1:    '# 5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'Objektumok – haladó 1 / 2',
        question:   'Az alábbiak közül melyik nem egy property descriptor?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['enumerable',
                    'configurable',
                    'writable',
                    'readable'],
        results:    'D',
        result:     4,
        boolres:    [false, false, false, true],
        answer:     'writable: módosítható e vagy sem<br>configurable: törölhető e<br>enumerable: felsorolható e'
    },
    {
        header1:    '# 5. JavaScript haladó - Objektum Orientált Programozás',
        header2:    'Objektumok – haladó 2 / 2',
        question:   'Minek van prototype tulajdonsága?<br>Válaszd ki az EGYETLEN megfelelő választ!',
        options:    ['minden objektumnak',
                    'minden függvénynek',
                    'minden primitívnek',
                    'minden objektumnak ami nem függvény'],
        results:    'B',
        result:     2,
        boolres:    [false, true, false, false],
        answer:     'Függvénynek prototype tulajdonsága van, az objecteknek (minden típusú objectnek a függvényeket is beleértve), pedig [[Prototype]] (is).'
    },
];